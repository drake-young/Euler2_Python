# ===========================================================
# PROBLEM 2 -- Even Fibonacci numbers
# ===========================================================
#
# Each new term in the Fibonacci sequence is generated by
# adding the previous two terms. By starting with 1 and 2,
# the first 10 terms will be:
#
#       1, 2, 3, 5, 8, 13, 21, 34, 55, 89
#
# By considering the terms in the Fibonacci sequence whose
# values do not exceed four million, find the sum of the even
# valued terms.
#
# ===========================================================
from timeit  import  default_timer
from math    import  sqrt

# Compute the nth fibonacci number using the closed-form formula
# Utility Function:  use the closed form formula to compute the nth fib number
# Description:
#   1. store the square root of five as a variable (so it only needs to
#      be computed once
#   2. use the parameter n and the square root of five in the closed-form
#      formula to compute the nth fibonacci number
#   3. cast the result of the computation to an integer and return the value
def compute_fibonacci( n=0 ):
    root_five  =  sqrt( 5 )
    return int( ( ( 1 / root_five ) * ( ( ( 0.5 * ( 1 + root_five ) )**n ) - ( ( 0.5 * ( 1 - root_five ) )**n ) ) ) )



# Method A:  Closed-Form Formula
# Description:
#   1. starting at Fib(3)=2, compute every third fibonacci (the only even ones)
#   2. as long as the computed fibonacci value is <4000000, continue
#   3. once results are >=4000000, display result of calculations
# Note:
#   Only calculation is timed, not result output
def problem_2_method_a( maximum=4000000 ):
    # Print Problem Context (unnecessary)
    print( "Project Euler Problem 2 -- Method 1 (Closed-Form Formula)")

    # Set up Variables
    start_time  =  default_timer( )  # Start Timer
    fib_value   =  0                 # Value of Current Fibonacci number
    result      =  0                 # Calculated Result
    i           =  3                 # Loop iteration value. Every third  Fibonacci number is even after 2

    # Main Loop, compute every third Fibonacci number and add to result
    while fib_value < maximum:
        # Retrieve the value of the ith fibonacci number
        fib_value = compute_fibonacci( i )

        # Even is already ensured, simply check if it's less than maximum
        if fib_value < maximum:
            result  +=  fib_value

        # every third fibonacci is even ( 1 , 1 , 2 , 3 , 5 , 8 , ... )
        i  +=  3  # every third fibonacci is even after 2
        continue

    # Calculate Execution Time
    end_time        =  default_timer( )
    execution_time  =  ( end_time - start_time ) * 1000

    # Print Results
    print( "   Sum of even valued Fibonacci numbers:   %d"        %  result )
    print( "   Calculation Time:                       %.3fms\n"  %  execution_time )
    return



#calculating fibonacci as sum of previous 2
# Method B:  Sequence Calculation
# Description:
#   1. using Fib(n) = Fib(n-1) + Fib(n-2), compute each fibonacci number
#      less than 4000000
#   2. if the fibonacci number is even, add it to the result
# Note:
#   Only calculation is timed, not result output
def problem_2_method_b( maximum=4000000 ):
    # Print Problem Context (unnecessary)
    print( "Project Euler Problem 2 -- Method 1 (Closed-Form Formula)" )

    # Prepare Variables
    start_time  =  default_timer( )  # Start Timer
    fib_a       =  1                 # First Fibonacci Number
    fib_b       =  1                 # Second Fibonacci Number
    result      =  0                 # Variable to Store the Answer

    # Driver Loop (iterate through all fibonacci < 4000000
    while fib_b < maximum:
        if fib_b % 2 is 0:
            result  +=  fib_b
        fib_a, fib_b = fib_b, ( fib_a + fib_b )

    # Calculate Execution Time
    end_time        =  default_timer( )
    execution_time  =  ( end_time - start_time ) * 1000

    # Print Results
    print( "   Sum of even valued Fibonacci numbers:   %d"        %  result )
    print( "   Calculation Time:                       %.3fms\n"  %  execution_time )
    return

def main( ):
    problem_2_method_a( )
    problem_2_method_b( )
    return

if __name__  ==  '__main__':
    main( )
